# Предварительно проект надо завести в gitLab.com, в нем завести ранер с локальной машины.
# Установка ранера: 
#   # Run PowerShell: https://docs.microsoft.com/en-us/powershell/scripting/windows-powershell/starting-windows-powershell?view=powershell-7#with-administrative-privileges-run-as-administrator
#   # Create a folder somewhere on your system, for example: C:\GitLab-Runner
#     New-Item -Path 'C:\GitLab-Runner' -ItemType Directory
#     
#     # Change to the folder
#     cd 'C:\GitLab-Runner'
#     
#     # Download binary
#     Invoke-WebRequest -Uri "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-windows-amd64.exe" -OutFile "gitlab-runner.exe"
#     
#     # Register the runner (steps below), then run
#     .\gitlab-runner.exe install
#     .\gitlab-runner.exe start
#  Command to register runner
#  ./gitlab-runner.exe register --url https://gitlab.com/ --registration-token GR1348941LovGGEx4-4fnm9iPJt3b
# Запустить VPN, иначе ошибка на шаге "docker login" (иногда впн мешает работе загрузок внутри ранера)
# В папке с ранером установить привелигированный режим иначе не будет доступа к докеру. Иначе ошибка на шаге "docker build": ERROR: Cannot connect to the Docker daemon at tcp://thedockerhost:2375/. Is the docker daemon running?

# Тут перечисляются глобальные переменные для пайплайна.
# Их мы будем использовать дальше в файле.
# Блок переменных имеет зарезервированное имя variables, которое не должно использоваться в качестве имени шага:
variables:
  JAVA_VERSION: 17
  APP_IMAGE: registry.gitlab.com/piloting1/skillbox # pilot_repo/user-app - эта штука должна совпадать с именем репо в гитЛабе
  # В переменных можно ссылаться на другие переменные, в том числе те, которые предоставляет GitLab.
  # Таких переменных довольно много, и можно, например, получить информацию о теге коммита:
  APP_TAG: 0.1.0-$CI_COMMIT_REF_NAME

# Здесь перечислены этапы сборки в нужном порядке.
# Называть этапы можно как угодно:
stages:
  - build
  - build_image
  - install

# Чтобы использовать результаты сборки на разных шагах, добавим кеш, иначе собрать артефакт с JAR-файлом, полученным на этапе build_app, нельзя:
cache:
  key: "$CI_COMMIT_REF_SLUG-build-cache"
  paths:
    - target/

# Далее описываем шаги сборки. Называть их можно практически как угодно, нельзя лишь использовать зарезервированные имена:
build_app:
  # Привязываем шаг к определённому этапу:
  stage: build
  tags:
    - java
  # Указываем образ, который будет использоваться для выполнения шага:
  image: maven:3-openjdk-$JAVA_VERSION
  # В разделе скрипта задаём команду, которую хотим выполнить:
  script: "mvn -B install --file pom.xml"
  artifacts: 
    paths:
      - target

docker-build:
  stage: build_image
  tags:
    - java
  # Для сборки образа будем использовать механизм docker in docker:
  image: docker:stable
  # Во внутреннем блоке variables можно задавать локальные переменные шага:
  variables:
    DOCKER_HOST: tcp://thedockerhost:2375/
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
  # Раздел services позволяет добавить к сборке ещё несколько образов.
  # Например, для docker in docker нам нужен образ с демоном. 
  # Другой пример: можно добавить БД для интеграционных тестов в отдельном образе.
  # Все эти образы будут работать вместе на текущем шаге:
  services:
    - name: docker:dind
      alias: thedockerhost
      
  # В разделе before_script можно указать шаги, которые необходимо выполнить перед основным скриптом.
  # Обратите внимание на переменные, которых нет в файле пайплайна, они задаются в настройках проекта.
  # Это позволяет хранить чувствительные данные отдельно от кода, причём благодаря ролевой модели GitLab.
  # Доступ к ним можно оставить только администратору или владельцу проекта, что повышает безопасность:
  before_script:
    #- docker login -u suntsovto -p myDockerPass "$CI_REGISTRY"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  # Если скрипт состоит более чем из одной команды, то удобно использовать list-форму.
  # В этой форме каждая команда записывается в отдельный элемент списка, что повышает читаемость файла:
  script:
    - docker image build -t $APP_IMAGE:$APP_TAG -f docker/Dockerfile .
    - docker push $APP_IMAGE:$APP_TAG
    - docker info
    - cd .charts/app/user-app
    - helm lint .
    - kubectl cluster-info

.install_dev:
  # Привязываем шаг к определённому этапу:
  stage: install
  tags:
    - java
  # Указываем образ, который будет использоваться для выполнения шага:
  image:
    name: alpine/helm
    entrypoint: [""]
  # В разделе скрипта задаём команду, которую хотим выполнить:
  script: 
    - cd .charts/app/user-app
    - helm lint .
    - kubectl cluster-info
    - helm upgrade user-app . -f values-dev.yaml